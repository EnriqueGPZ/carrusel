<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Panorama Studio Pro (Precisión Numérica)</title>

  <!-- Fuentes -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Playfair+Display:wght@400;700&family=Montserrat:wght@400;700&family=Oswald:wght@400;700&family=Dancing+Script:wght@400;700&family=Poppins:wght@400;700&family=Roboto+Slab:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Lato:wght@400;700&family=Open+Sans:wght@400;700&family=Merriweather:wght@400;700&family=Cabin:wght@400;700&family=Pacifico&display=swap" rel="stylesheet">

  <!-- React & Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Fabric.js, JSZip, FileSaver, Lucide -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    /* Estilos base y bloqueo de scroll */
    html, body {
      width: 100%; height: 100%;
      margin: 0; padding: 0;
      position: fixed; top: 0; left: 0;
      overflow: hidden !important; 
      overscroll-behavior: none;
      background-color: #09090b;
      font-family: 'Inter', sans-serif;
    }
    #root { width: 100%; height: 100%; position: absolute; inset: 0; }

    /* Canvas Viewport */
    .viewport-container {
      width: 100%; height: 100%;
      position: absolute; inset: 0;
      background-image: radial-gradient(#27272a 1px, transparent 1px);
      background-size: 24px 24px;
      cursor: grab;
      z-index: 0;
      touch-action: none;
      will-change: transform;
      transition: box-shadow 0.2s, background-color 0.2s;
    }
    .viewport-container.is-panning { cursor: grabbing; }
    .viewport-container.drag-active {
        box-shadow: inset 0 0 0 4px #3b82f6;
        background-color: rgba(59, 130, 246, 0.1);
    }

    /* Paneles de UI */
    .glass-panel {
      background: rgba(24, 24, 27, 0.95);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    .color-swatch {
      width: 24px; height: 24px;
      border-radius: 999px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 100ms;
    }
    .color-swatch.active { border-color: white; transform: scale(1.1); box-shadow: 0 0 8px rgba(255,255,255,0.5); }
    
    .btn-icon {
      padding: 8px;
      border-radius: 8px;
      color: #a1a1aa;
      display: inline-flex;
      align-items: center; justify-content: center;
      transition: all 0.2s;
      cursor: pointer;
    }
    .btn-icon:hover { color: white; background: rgba(255,255,255,0.1); }
    .btn-icon:active { transform: scale(0.95); }
    .btn-icon.active { color: #fff; background: #3b82f6; }
    
    .cursor-move-grab { cursor: grab; }
    .cursor-move-grab:active { cursor: grabbing; }

    /* Inputs numéricos */
    .num-input-group {
        display: flex; flex-direction: column; gap: 2px;
    }
    .num-input-label {
        font-size: 9px; font-weight: 700; color: #71717a; text-transform: uppercase;
    }
    .num-input {
        background: #18181b; border: 1px solid #3f3f46; color: white;
        border-radius: 6px; padding: 4px 6px; font-size: 11px; width: 100%;
        outline: none; transition: border-color 0.2s;
    }
    .num-input:focus { border-color: #3b82f6; }

    /* Modal */
    .modal-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      display: flex; align-items: center; justify-content: center;
      z-index: 100;
      animation: fadeIn 0.2s ease-out;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

    /* Range Slider */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 16px; width: 16px;
      border-radius: 50%; background: #fff;
      cursor: pointer; margin-top: -6px;
    }
    input[type="range"]::-webkit-slider-runnable-track {
      width: 100%; height: 4px;
      cursor: pointer; background: #444; border-radius: 2px;
    }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState } = React;

    // --- CONFIG ---
    const SLIDE_W = 1080;
    const SLIDE_H = 1350;
    const SNAP_DIST = 20; 
    
    const COLORS = ['#000000', '#FFFFFF', '#F87171', '#FB923C', '#FBBF24', '#34D399', '#22D3EE', '#60A5FA', '#818CF8', '#A78BFA', '#E879F9', '#FB7185', '#e4e4e7', '#52525b'];
    
    const FONTS = [
      { name: 'Moderna (Inter)', family: 'Inter' },
      { name: 'Elegante (Playfair)', family: 'Playfair Display' },
      { name: 'Geométrica (Montserrat)', family: 'Montserrat' },
      { name: 'Impacto (Oswald)', family: 'Oswald' },
      { name: 'Manuscrita (Dancing)', family: 'Dancing Script' },
      { name: 'Universal (Poppins)', family: 'Poppins' },
      { name: 'Robusta (Roboto Slab)', family: 'Roboto Slab' },
      { name: 'Código (Source Code Pro)', family: 'Source Code Pro' },
    ];

    const clamp = (n, a, b) => Math.min(Math.max(n, a), b);

    const App = () => {
      const canvasElRef = useRef(null);
      const containerRef = useRef(null);
      const fileInputRef = useRef(null);
      const fabricRef = useRef(null);
      const guidesCacheRef = useRef([]);
      const historyRef = useRef({ stack: [], index: -1, isApplying: false });

      // STATES
      const [slides, setSlides] = useState(3);
      const [showHGuide, setShowHGuide] = useState(false);
      const [selected, setSelected] = useState(null);
      // Estado para propiedades numéricas (X, Y, W, H)
      const [selProps, setSelProps] = useState({ x: 0, y: 0, w: 0, h: 0 });

      const [view, setView] = useState({ x: 0, y: 0, zoom: 0.25 });
      const [isExporting, setIsExporting] = useState(false);
      const [isDraggingFile, setIsDraggingFile] = useState(false); 
      
      // Panel Flotante
      const [panelPos, setPanelPos] = useState({ x: window.innerWidth - 280, y: 100 });
      const [isDraggingPanel, setIsDraggingPanel] = useState(false);
      const panelDragOffset = useRef({ x: 0, y: 0 });

      // Modal Texto
      const [modalOpen, setModalOpen] = useState(false);
      const [textState, setTextState] = useState({ 
        content: '', color: '#FFFFFF', fontSize: 120, 
        fontFamily: 'Inter', fontWeight: 'normal', fontStyle: 'normal', objRef: null 
      });

      // Paneo
      const [isPanning, setIsPanning] = useState(false);
      const panRef = useRef({ startX: 0, startY: 0 });
      const [spaceDown, setSpaceDown] = useState(false);

      const totalW = useMemo(() => slides * SLIDE_W, [slides]);

      // --- HISTORIAL ---
      const serialize = (c) => c.toJSON(['isGuide', 'isHGuide', 'excludeFromExport']);
      
      const pushHistory = () => {
        const c = fabricRef.current;
        if (!c || historyRef.current.isApplying) return;
        const json = JSON.stringify(serialize(c));
        const h = historyRef.current;
        if (h.index >= 0 && h.stack[h.index] === json) return;
        h.stack = h.stack.slice(0, h.index + 1);
        h.stack.push(json);
        h.index = h.stack.length - 1;
        if (h.stack.length > 50) { h.stack.shift(); h.index--; }
      };

      const applyHistory = (dir) => {
        const c = fabricRef.current;
        const h = historyRef.current;
        const next = clamp(h.index + dir, 0, h.stack.length - 1);
        if (!c || next === h.index) return;
        h.isApplying = true;
        h.index = next;
        c.loadFromJSON(JSON.parse(h.stack[next]), () => {
          drawGuides(c, slides, showHGuide);
          bringGuidesTop(c);
          c.requestRenderAll();
          h.isApplying = false;
        });
      };

      // --- INIT FABRIC ---
      useEffect(() => {
        const c = new fabric.Canvas(canvasElRef.current, {
          height: SLIDE_H, width: totalW,
          backgroundColor: '#ffffff',
          preserveObjectStacking: true,
          selection: true,
          renderOnAddRemove: false, 
          enableRetinaScaling: false, 
          uniformScaling: true 
        });
        fabricRef.current = c;

        // Función auxiliar para actualizar props numéricos
        const updateSelProps = (act) => {
             if (!act) return;
             setSelProps({
                 x: Math.round(act.left),
                 y: Math.round(act.top),
                 w: Math.round(act.getScaledWidth()),
                 h: Math.round(act.getScaledHeight())
             });
        };

        const updateSel = () => {
          const act = c.getActiveObject();
          setSelected(act ? { type: act.type, fill: act.fill } : null);
          updateSelProps(act);
        };
        
        c.on('selection:created', updateSel);
        c.on('selection:updated', updateSel);
        c.on('selection:cleared', () => { setSelected(null); });
        c.on('object:modified', () => { 
            resetGuidesColor(); 
            pushHistory(); 
            updateSel(); 
        });
        // Actualizar números en tiempo real mientras se mueve/escala
        c.on('object:moving', (e) => { handleSnapMoving(e, slides, showHGuide); updateSelProps(e.target); });
        c.on('object:scaling', (e) => { handleSnapScaling(e, slides); updateSelProps(e.target); });

        c.on('mouse:dblclick', (e) => {
          if (e.target && e.target.type === 'text') {
            setTextState({
              content: e.target.text, color: e.target.fill, fontSize: e.target.fontSize,
              fontFamily: e.target.fontFamily, fontWeight: e.target.fontWeight, fontStyle: e.target.fontStyle,
              objRef: e.target
            });
            setModalOpen(true);
          }
        });

        drawGuides(c, slides, showHGuide);
        c.renderAll();
        pushHistory();
        setTimeout(() => centerView(totalW), 100);
        setTimeout(() => lucide.createIcons(), 100);

        return () => c.dispose();
      }, [slides]);

      useEffect(() => {
        if (fabricRef.current) {
            drawGuides(fabricRef.current, slides, showHGuide);
            bringGuidesTop(fabricRef.current);
            fabricRef.current.requestRenderAll();
        }
      }, [showHGuide, slides]);

      useEffect(() => { try { lucide.createIcons(); } catch(_) {} }, [selected, modalOpen, isDraggingFile, showHGuide]);

      // --- LOGICA PANEL FLOTANTE ---
      useEffect(() => {
        const handleWindowMouseMove = (e) => {
            if (isDraggingPanel) {
                setPanelPos({
                    x: clamp(e.clientX - panelDragOffset.current.x, 0, window.innerWidth - 240),
                    y: clamp(e.clientY - panelDragOffset.current.y, 0, window.innerHeight - 300) 
                });
            }
        };
        const handleWindowMouseUp = () => setIsDraggingPanel(false);
        if (isDraggingPanel) {
            window.addEventListener('pointermove', handleWindowMouseMove);
            window.addEventListener('pointerup', handleWindowMouseUp);
        }
        return () => {
            window.removeEventListener('pointermove', handleWindowMouseMove);
            window.removeEventListener('pointerup', handleWindowMouseUp);
        };
      }, [isDraggingPanel]);

      const startDragPanel = (e) => {
        e.stopPropagation(); e.preventDefault();
        const rect = e.currentTarget.parentElement.getBoundingClientRect();
        panelDragOffset.current = { x: e.clientX - rect.left, y: e.clientY - rect.top };
        setIsDraggingPanel(true);
      };

      // --- MANIPULACIÓN NUMÉRICA ---
      const handleNumChange = (key, val) => {
        const c = fabricRef.current;
        const act = c.getActiveObject();
        if (!act) return;
        
        const numVal = parseInt(val, 10);
        if (isNaN(numVal)) return;

        if (key === 'x') act.set('left', numVal);
        if (key === 'y') act.set('top', numVal);
        if (key === 'w') {
            const scale = numVal / act.width;
            act.set({ scaleX: scale, scaleY: scale }); // Bloqueamos ratio para fotos
        }
        if (key === 'h') {
            const scale = numVal / act.height;
            act.set({ scaleX: scale, scaleY: scale });
        }
        
        act.setCoords();
        c.requestRenderAll();
        setSelProps(prev => ({ ...prev, [key]: numVal }));
        pushHistory();
      };

      // --- ALINEACIÓN INTELIGENTE ---
      const alignObject = (direction) => {
          const c = fabricRef.current;
          const act = c.getActiveObject();
          if(!act) return;

          // 1. Detectar en qué slide está el objeto (basado en su centro)
          const center = act.getCenterPoint();
          const slideIndex = Math.floor(center.x / SLIDE_W);
          const currentSlideX = slideIndex * SLIDE_W;

          // 2. Calcular nuevas coordenadas
          if (direction === 'h-center') {
              const newLeft = currentSlideX + (SLIDE_W - act.getScaledWidth()) / 2;
              act.set('left', newLeft);
          }
          if (direction === 'v-center') {
              const newTop = (SLIDE_H - act.getScaledHeight()) / 2;
              act.set('top', newTop);
          }

          act.setCoords();
          c.requestRenderAll();
          pushHistory();
          // Actualizar inputs
          setSelProps({
             x: Math.round(act.left), y: Math.round(act.top),
             w: Math.round(act.getScaledWidth()), h: Math.round(act.getScaledHeight())
          });
      };

      // --- CAMBIAR COLOR ---
      const handleShapeColorChange = (color) => {
        const c = fabricRef.current;
        const act = c.getActiveObject();
        if (act && (act.type === 'rect' || act.type === 'circle' || act.type === 'triangle')) {
            act.set('fill', color);
            setSelected(prev => ({ ...prev, fill: color }));
            c.requestRenderAll();
            pushHistory();
        }
      };

      // --- SNAP ENGINE ---
      const resetGuidesColor = () => {
        let dirty = false;
        guidesCacheRef.current.forEach(o => {
            if (o.stroke !== '#3b82f6' || o.strokeWidth !== 2) {
                o.set({ stroke: '#3b82f6', strokeWidth: 2, opacity: 0.5 }); 
                dirty = true;
            }
        });
        if (dirty) fabricRef.current.requestRenderAll();
      };

      const highlightGuide = (targetPos, isHorizontal = false) => {
        let dirty = false;
        guidesCacheRef.current.forEach(o => {
            let match = false;
            if (isHorizontal && o.isHGuide) {
                if (Math.abs(o.y1 - targetPos) < 1) match = true;
            } else if (!isHorizontal && !o.isHGuide) {
                if (Math.abs(o.x1 - targetPos) < 1) match = true;
            }
            if (match) {
                if (o.stroke !== '#06b6d4') { o.set({ stroke: '#06b6d4', strokeWidth: 4, opacity: 1 }); dirty = true; }
            }
        });
        if (dirty) fabricRef.current.requestRenderAll();
      };

      const handleSnapMoving = (e, n, useHGuide) => {
        const obj = e.target; if (!obj || obj.isGuide) return;
        const w = obj.getScaledWidth();
        const h = obj.getScaledHeight();
        let snapped = false;

        const vTargets = [];
        for (let i = 0; i <= n; i++) { vTargets.push(i * SLIDE_W); if (i < n) vTargets.push(i * SLIDE_W + SLIDE_W / 2); }
        
        vTargets.forEach(t => {
            if (Math.abs(obj.left - t) < SNAP_DIST) { obj.left = t; snapped = true; highlightGuide(t, false); }
            else if (Math.abs((obj.left + w) - t) < SNAP_DIST) { obj.left = t - w; snapped = true; highlightGuide(t, false); }
            else if (Math.abs((obj.left + w / 2) - t) < SNAP_DIST) { obj.left = t - w / 2; snapped = true; highlightGuide(t, false); }
        });

        if (useHGuide) {
            const midY = SLIDE_H / 2;
            if (Math.abs((obj.top + h/2) - midY) < SNAP_DIST) { 
                obj.top = midY - h/2; snapped = true; highlightGuide(midY, true); 
            }
        }
        if (!snapped) resetGuidesColor();
      };

      const handleSnapScaling = (e, n) => {
        const obj = e.target; if (!obj || obj.isGuide) return;
        const targets = []; for (let i = 0; i <= n; i++) targets.push(i * SLIDE_W); 
        const right = obj.left + (obj.width * obj.scaleX);
        let snapped = false;
        targets.forEach(t => {
            if (Math.abs(right - t) < SNAP_DIST) {
                const ns = (t - obj.left) / obj.width;
                if (ns > 0) { obj.scaleX = ns; if (obj.type === 'image') obj.scaleY = ns; snapped = true; highlightGuide(t, false); }
            }
        });
        if (!snapped) resetGuidesColor();
      };

      const drawGuides = (c, n, showH) => {
        const oldGuides = c.getObjects().filter(o => o.isGuide);
        oldGuides.forEach(o => c.remove(o));
        guidesCacheRef.current = [];

        for(let i=0; i<=n; i++) { 
          if (i > 0 && i < n) {
             const g = new fabric.Line([i*SLIDE_W, 0, i*SLIDE_W, SLIDE_H], {
                stroke: '#3b82f6', strokeWidth: 2, strokeDashArray: [10,10], 
                selectable: false, evented: false, opacity: 0.5, isGuide: true, originX: 'center'
             });
             c.add(g); guidesCacheRef.current.push(g);
          }
        }
        if (showH) {
            const hGuide = new fabric.Line([0, SLIDE_H / 2, n * SLIDE_W, SLIDE_H / 2], {
                stroke: '#3b82f6', strokeWidth: 2, strokeDashArray: [10, 10],
                selectable: false, evented: false, opacity: 0.5, 
                isGuide: true, isHGuide: true, originY: 'center'
            });
            c.add(hGuide); guidesCacheRef.current.push(hGuide);
        }
      };
      const bringGuidesTop = (c) => guidesCacheRef.current.forEach(o => c.bringToFront(o));

      // --- TEXTO ---
      const openNewTextModal = () => {
        setTextState({ content: '', color: '#000000', fontSize: 120, fontFamily: 'Inter', fontWeight: 'bold', fontStyle: 'normal', objRef: null });
        setModalOpen(true);
      };
      const handleSaveText = () => {
        const c = fabricRef.current;
        if (!c || !textState.content.trim()) { setModalOpen(false); return; }
        const props = { text: textState.content, fill: textState.color, fontSize: textState.fontSize, fontFamily: textState.fontFamily, fontWeight: textState.fontWeight, fontStyle: textState.fontStyle };
        if (textState.objRef) textState.objRef.set(props);
        else { const t = new fabric.Text(props.text, { ...props, left: totalW / 2, top: SLIDE_H / 2, originX: 'center', originY: 'center', centeredRotation: true }); c.add(t); c.setActiveObject(t); }
        bringGuidesTop(c); c.requestRenderAll(); pushHistory(); setModalOpen(false);
      };

      // --- TECLADO (AHORA CON MICRO-AJUSTES) ---
      useEffect(() => {
        const handleKey = (e) => {
          if (modalOpen) return;
          const c = fabricRef.current;
          const act = c?.getActiveObject();
          const mod = e.metaKey || e.ctrlKey;
          const shift = e.shiftKey;
          const dist = shift ? 10 : 1; // 10px con Shift, 1px normal

          if (e.key === 'Backspace' || e.key === 'Delete') deleteItem();
          if (mod && e.key === 'z') { e.preventDefault(); e.shiftKey ? applyHistory(1) : applyHistory(-1); }
          if (e.code === 'Space') { if (e.type === 'keydown') setSpaceDown(true); else setSpaceDown(false); }
          if (mod && e.key === '0') { e.preventDefault(); centerView(); }

          // FLECHAS
          if (act && (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
              e.preventDefault();
              if (e.key === 'ArrowLeft') act.left -= dist;
              if (e.key === 'ArrowRight') act.left += dist;
              if (e.key === 'ArrowUp') act.top -= dist;
              if (e.key === 'ArrowDown') act.top += dist;
              act.setCoords();
              c.requestRenderAll();
              
              // Actualizar UI numérica sin llenar el historial cada milisegundo
              setSelProps({
                 x: Math.round(act.left), y: Math.round(act.top),
                 w: Math.round(act.getScaledWidth()), h: Math.round(act.getScaledHeight())
              });
          }
        };
        window.addEventListener('keydown', handleKey); window.addEventListener('keyup', handleKey);
        return () => { window.removeEventListener('keydown', handleKey); window.removeEventListener('keyup', handleKey); };
      }, [modalOpen]);

      // --- FUNCIONES VIEWPORT ---
      const centerView = (w = totalW) => {
        if (!containerRef.current) return;
        const cw = containerRef.current.clientWidth; const ch = containerRef.current.clientHeight;
        const scale = Math.min((cw - 100) / w, (ch - 100) / SLIDE_H, 0.9);
        setView({ x: (cw - w * scale)/2, y: (ch - SLIDE_H * scale)/2, zoom: scale });
      };
      const zoomAtCenter = (factor) => {
        const rect = containerRef.current.getBoundingClientRect();
        const nextZoom = clamp(view.zoom * factor, 0.05, 5);
        setView(v => ({ zoom: nextZoom, x: (rect.width/2) - ((rect.width/2) - v.x) * (nextZoom / v.zoom), y: (rect.height/2) - ((rect.height/2) - v.y) * (nextZoom / v.zoom) }));
      };

      // --- GESTION ITEMS ---
      const addRect = () => {
        const r = new fabric.Rect({ left: totalW/2 - 200, top: SLIDE_H/2 - 200, width: 400, height: 400, fill: '#e4e4e7' });
        fabricRef.current.add(r); fabricRef.current.setActiveObject(r); pushHistory(); fabricRef.current.requestRenderAll();
      };
      
      const deleteItem = () => {
        const c = fabricRef.current; const act = c.getActiveObject();
        if (act) { c.remove(act); c.discardActiveObject(); pushHistory(); c.requestRenderAll(); }
      };
      
      const layerAction = (action) => {
        const c = fabricRef.current; const act = c.getActiveObject(); if (!act) return;
        if (action === 'top') c.bringToFront(act);
        else if (action === 'up') c.bringForward(act, true); 
        else if (action === 'down') c.sendBackwards(act, true); 
        else if (action === 'bottom') c.sendToBack(act);
        bringGuidesTop(c); c.requestRenderAll(); pushHistory();
      };

      // --- LOGICA IMAGENES ---
      const processImageFile = (file, dropCoords = null) => {
        if (!file || !file.type.startsWith('image/')) return;
        const url = URL.createObjectURL(file);
        fabric.Image.fromURL(url, (img) => {
            const scale = (Math.min(SLIDE_W, SLIDE_H) * 0.5) / Math.max(img.width, img.height);
            let left, top;
            if (dropCoords) {
                left = (dropCoords.x - view.x) / view.zoom - (img.width * scale) / 2;
                top = (dropCoords.y - view.y) / view.zoom - (img.height * scale) / 2;
            } else {
                left = totalW / 2 - (img.width * scale) / 2;
                top = SLIDE_H / 2 - (img.height * scale) / 2;
            }
            img.set({ left, top, scaleX: scale, scaleY: scale, uniformScaling: true });
            fabricRef.current.add(img); fabricRef.current.setActiveObject(img); 
            pushHistory(); fabricRef.current.requestRenderAll();
        });
      };
      const handleInputImage = (e) => { processImageFile(e.target.files[0]); e.target.value = ''; };
      const onDragOver = (e) => { e.preventDefault(); setIsDraggingFile(true); };
      const onDragLeave = (e) => { e.preventDefault(); setIsDraggingFile(false); };
      const onDrop = (e) => {
        e.preventDefault(); setIsDraggingFile(false);
        const files = e.dataTransfer.files;
        if (files && files.length > 0) { processImageFile(files[0], { x: e.clientX, y: e.clientY }); }
      };

      const handleExport = async () => {
        setIsExporting(true);
        const c = fabricRef.current;
        guidesCacheRef.current.forEach(g => g.visible = false); c.renderAll();
        const zip = new JSZip();
        for (let i = 0; i < slides; i++) {
            const data = c.toDataURL({ left: i * SLIDE_W, top: 0, width: SLIDE_W, height: SLIDE_H, format: 'png', multiplier: 1.5 });
            zip.file(`slide-${i+1}.png`, data.split(',')[1], {base64: true});
        }
        guidesCacheRef.current.forEach(g => g.visible = true); c.renderAll();
        const blob = await zip.generateAsync({type:'blob'});
        saveAs(blob, 'panorama-carrusel.zip');
        setIsExporting(false);
      };

      return (
        <div className="w-full h-full select-none text-zinc-200">
          
          <header className="fixed top-6 left-0 right-0 flex justify-center z-50 pointer-events-none">
            <div className="glass-panel rounded-full px-2 py-2 flex items-center gap-4 pointer-events-auto">
                <div className="flex items-center gap-2 px-3 border-r border-white/10">
                    <div className="w-3 h-3 rounded-full bg-gradient-to-r from-pink-500 to-violet-500"></div>
                    <span className="font-bold text-sm">Panorama</span>
                </div>
                <div className="flex items-center gap-2">
                    <span className="text-xs text-zinc-500">SLIDES</span>
                    <select value={slides} onChange={e => setSlides(Number(e.target.value))} className="bg-zinc-800 rounded px-2 py-1 text-xs font-bold outline-none cursor-pointer">
                        {[2,3,4,5,6,7,8,9,10].map(n => <option key={n} value={n}>{n}</option>)}
                    </select>
                </div>
                <button onClick={() => setShowHGuide(!showHGuide)} className={`btn-icon ${showHGuide ? 'active' : ''}`} title="Guía Central Horizontal">
                  <i data-lucide="rows" className="w-4 h-4"></i>
                </button>
                <div className="flex gap-1 border-l border-white/10 pl-2">
                    <button onClick={() => applyHistory(-1)} className="btn-icon"><i data-lucide="undo-2" className="w-4 h-4"></i></button>
                    <button onClick={() => applyHistory(1)} className="btn-icon"><i data-lucide="redo-2" className="w-4 h-4"></i></button>
                </div>
                <button onClick={handleExport} className="bg-white text-black px-4 py-1.5 rounded-full text-xs font-bold hover:bg-zinc-200 flex gap-2 items-center">
                    {isExporting ? '...' : <><i data-lucide="download" className="w-3 h-3"></i> Guardar</>}
                </button>
            </div>
          </header>

          <main 
            ref={containerRef}
            className={`viewport-container ${isPanning ? 'is-panning' : ''} ${isDraggingFile ? 'drag-active' : ''}`}
            onDragOver={onDragOver} onDragLeave={onDragLeave} onDrop={onDrop}
            onPointerDown={e => {
                if (spaceDown || e.button===1 || e.button===2 || e.target===containerRef.current) {
                    e.preventDefault(); setIsPanning(true); panRef.current = {x: e.clientX-view.x, y: e.clientY-view.y};
                }
            }}
            onPointerMove={e => { if (isPanning) setView(v => ({ ...v, x: e.clientX-panRef.current.x, y: e.clientY-panRef.current.y })); }}
            onPointerUp={() => setIsPanning(false)}
            onWheel={e => { if(e.ctrlKey) { e.preventDefault(); zoomAtCenter(e.deltaY > 0 ? 0.9 : 1.1); } }}
            onContextMenu={e => e.preventDefault()}
          >
            {isDraggingFile && (
                <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-50">
                    <div className="bg-blue-600 text-white px-6 py-3 rounded-full font-bold text-xl shadow-xl animate-bounce">Suelta la imagen aquí</div>
                </div>
            )}
            <div style={{ transform: `translate(${view.x}px, ${view.y}px) scale(${view.zoom})`, transformOrigin: '0 0', width: totalW, height: SLIDE_H, position: 'absolute', boxShadow: '0 0 50px rgba(0,0,0,0.5)' }}>
                <canvas ref={canvasElRef} />
            </div>
          </main>

          <div className="fixed bottom-8 left-1/2 -translate-x-1/2 z-40">
            <div className="glass-panel p-2 rounded-2xl flex items-center gap-2">
                <button onClick={openNewTextModal} className="btn-icon" title="Texto"><i data-lucide="type" className="w-6 h-6"></i></button>
                <button onClick={addRect} className="btn-icon" title="Forma"><i data-lucide="square" className="w-6 h-6"></i></button>
                <div className="relative">
                    <button onClick={() => fileInputRef.current.click()} className="btn-icon" title="Imagen"><i data-lucide="image" className="w-6 h-6"></i></button>
                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleInputImage} className="hidden" />
                </div>
                <div className="w-px h-8 bg-white/10 mx-1"></div>
                <button onClick={() => centerView()} className="btn-icon"><i data-lucide="maximize" className="w-5 h-5"></i></button>
                <button onClick={() => zoomAtCenter(0.8)} className="btn-icon"><i data-lucide="minus" className="w-5 h-5"></i></button>
                <button onClick={() => zoomAtCenter(1.2)} className="btn-icon"><i data-lucide="plus" className="w-5 h-5"></i></button>
            </div>
          </div>

          {selected && !modalOpen && (
            <div 
                className="fixed w-64 glass-panel rounded-2xl p-4 flex flex-col gap-4 z-50 shadow-2xl animate-[fadeIn_0.2s]"
                style={{ left: panelPos.x, top: panelPos.y }}
            >
                <div className="flex justify-between items-center pb-2 border-b border-white/10 cursor-move-grab" onPointerDown={startDragPanel}>
                    <div className="flex items-center gap-2">
                        <i data-lucide="grip-horizontal" className="w-4 h-4 text-zinc-500"></i>
                        <span className="text-xs font-bold text-zinc-500 uppercase select-none">Propiedades</span>
                    </div>
                    <button onPointerDown={e => e.stopPropagation()} onClick={deleteItem} className="text-red-400 p-1 hover:bg-red-400/10 rounded" title="Eliminar"><i data-lucide="trash-2" className="w-4 h-4"></i></button>
                </div>

                {/* --- NUEVO: INPUTS NUMERICOS --- */}
                <div className="grid grid-cols-2 gap-3">
                    <div className="flex gap-2">
                         <div className="num-input-group flex-1">
                            <label className="num-input-label">X</label>
                            <input type="number" value={selProps.x} onChange={(e) => handleNumChange('x', e.target.value)} className="num-input" />
                         </div>
                         <div className="num-input-group flex-1">
                            <label className="num-input-label">Y</label>
                            <input type="number" value={selProps.y} onChange={(e) => handleNumChange('y', e.target.value)} className="num-input" />
                         </div>
                    </div>
                    <div className="flex gap-2">
                         <div className="num-input-group flex-1">
                            <label className="num-input-label">Ancho</label>
                            <input type="number" value={selProps.w} onChange={(e) => handleNumChange('w', e.target.value)} className="num-input" />
                         </div>
                         <div className="num-input-group flex-1">
                            <label className="num-input-label">Alto</label>
                            <input type="number" value={selProps.h} onChange={(e) => handleNumChange('h', e.target.value)} className="num-input" />
                         </div>
                    </div>
                </div>

                {/* --- NUEVO: ALINEACIÓN --- */}
                <div>
                     <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block">Alineación (En Slide)</label>
                     <div className="flex gap-2">
                         <button onClick={() => alignObject('h-center')} className="btn-icon flex-1 bg-zinc-800 hover:bg-zinc-700 text-xs" title="Centrar Horizontalmente">
                            <i data-lucide="align-center-horizontal" className="w-4 h-4"></i>
                         </button>
                         <button onClick={() => alignObject('v-center')} className="btn-icon flex-1 bg-zinc-800 hover:bg-zinc-700 text-xs" title="Centrar Verticalmente">
                            <i data-lucide="align-center-vertical" className="w-4 h-4"></i>
                         </button>
                     </div>
                </div>
                
                {selected.type === 'text' && (
                    <div className="text-xs text-zinc-400 italic text-center py-2 bg-zinc-800/50 rounded">Doble clic para editar texto</div>
                )}
                
                {selected.type === 'rect' && (
                    <div>
                        <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block">Color</label>
                        <div className="flex flex-wrap gap-2">
                            {COLORS.map(c => (
                                <div key={c} onClick={() => handleShapeColorChange(c)} className={`color-swatch ${selected.fill === c ? 'active' : ''}`} style={{ backgroundColor: c }} title={c} />
                            ))}
                        </div>
                    </div>
                )}

                <div>
                    <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block">Capas</label>
                    <div className="flex justify-between items-center bg-zinc-900/50 rounded-lg p-1">
                        <button onClick={() => layerAction('bottom')} className="btn-icon w-8 h-8"><i data-lucide="chevrons-down" className="w-4 h-4"></i></button>
                        <div className="w-px h-4 bg-white/10"></div>
                        <button onClick={() => layerAction('down')} className="btn-icon w-8 h-8"><i data-lucide="minus" className="w-4 h-4"></i></button>
                        <button onClick={() => layerAction('up')} className="btn-icon w-8 h-8"><i data-lucide="plus" className="w-4 h-4"></i></button>
                        <div className="w-px h-4 bg-white/10"></div>
                        <button onClick={() => layerAction('top')} className="btn-icon w-8 h-8"><i data-lucide="chevrons-up" className="w-4 h-4"></i></button>
                    </div>
                </div>
            </div>
          )}

          {modalOpen && (
            <div className="modal-overlay">
                <div className="glass-panel p-6 rounded-3xl w-[90%] max-w-lg flex flex-col gap-5 shadow-2xl border border-white/20 animate-in fade-in zoom-in-95 duration-200">
                    <h2 className="text-lg font-bold text-white text-center tracking-tight">{textState.objRef ? 'Editar Texto' : 'Nuevo Texto'}</h2>
                    <textarea 
                        autoFocus
                        value={textState.content}
                        onChange={e => setTextState({...textState, content: e.target.value})}
                        style={{ fontFamily: textState.fontFamily, fontWeight: textState.fontWeight, fontStyle: textState.fontStyle }}
                        placeholder="Escribe tu texto aquí..."
                        className="w-full bg-black/40 border border-white/10 rounded-xl p-4 text-white text-2xl outline-none focus:border-blue-500 min-h-[120px] resize-none text-center"
                    />
                    <div className="grid grid-cols-2 gap-4">
                        <div className="flex flex-col gap-2">
                            <label className="text-[10px] font-bold text-zinc-500 uppercase">Tipografía</label>
                            <div className="flex flex-col gap-1 bg-black/20 p-1 rounded-xl max-h-40 overflow-y-auto">
                                {FONTS.map(f => (
                                    <button key={f.name} onClick={() => setTextState({...textState, fontFamily: f.family})} className={`px-3 py-2 text-left rounded-lg text-sm transition ${textState.fontFamily === f.family ? 'bg-blue-600 text-white' : 'text-zinc-400 hover:bg-white/5'}`} style={{ fontFamily: f.family }}>{f.name}</button>
                                ))}
                            </div>
                        </div>
                        <div className="flex flex-col gap-4">
                            <div>
                                <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block">Estilo</label>
                                <div className="flex gap-2">
                                    <button onClick={() => setTextState({...textState, fontWeight: textState.fontWeight === 'bold' ? 'normal' : 'bold'})} className={`flex-1 p-2 rounded-lg border transition font-bold ${textState.fontWeight === 'bold' ? 'bg-white text-black border-white' : 'border-zinc-700 text-zinc-500 hover:border-zinc-500'}`}>B</button>
                                    <button onClick={() => setTextState({...textState, fontStyle: textState.fontStyle === 'italic' ? 'normal' : 'italic'})} className={`flex-1 p-2 rounded-lg border transition italic ${textState.fontStyle === 'italic' ? 'bg-white text-black border-white' : 'border-zinc-700 text-zinc-500 hover:border-zinc-500'}`}>I</button>
                                </div>
                            </div>
                            <div>
                                <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block flex justify-between"><span>Tamaño</span> <span>{textState.fontSize}px</span></label>
                                <input type="range" min="40" max="400" step="10" value={textState.fontSize} onChange={e => setTextState({...textState, fontSize: parseInt(e.target.value)})} className="w-full h-1 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-white" />
                            </div>
                        </div>
                    </div>
                    <div>
                        <label className="text-[10px] font-bold text-zinc-500 uppercase mb-2 block">Color</label>
                        <div className="flex flex-wrap gap-2 justify-center bg-black/20 p-2 rounded-xl">
                            {COLORS.map(c => (
                                <div key={c} onClick={() => setTextState({...textState, color: c})} className={`color-swatch ${textState.color === c ? 'active' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                    </div>
                    <div className="flex gap-3 pt-2 border-t border-white/10">
                        <button onClick={() => setModalOpen(false)} className="flex-1 py-3 rounded-xl font-bold text-zinc-400 hover:bg-white/5 transition">Cancelar</button>
                        <button onClick={handleSaveText} className="flex-1 py-3 rounded-xl font-bold bg-white text-black hover:bg-zinc-200 transition">{textState.objRef ? 'Actualizar Texto' : 'Añadir Texto'}</button>
                    </div>
                </div>
            </div>
          )}

        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
